
// #include "circular_queue.h"

// #include <algorithm>
// #include <cstring>


// template<typename T>
// void CircularQueue<T>::enqueue(const T* bfr, uint16_t len) {
//   // If len > capacity, consider only the last <capacity> items.
//   if (len > _capacity) {
//     bfr += len - _capacity;
//     len = _capacity;
//   }
//   // Here len <= _capacity. 
//   // If needed, drops existing items to have room for <len> items.
//   if (_capacity - _size < len) {
//     const uint16_t items_to_drop = _size + len - _capacity;
//     _size -= items_to_drop;
//     _start += items_to_drop;
//     normalize_index(_start);
//   }
//   // Add the <len> items, in at most two chunks.
//   uint16_t items_added = 0;
//   while (items_added < len) {
//     const uint16_t limit1 = len - items_added;
//     uint16_t dst = _start + _size;
//     normalize_index(dst);
//     const uint16_t limit2 = (dst < _start) ? _start - dst : _capacity - dst;
//     const uint16_t n = std::min(limit1, limit2);
//     memcpy(&_buffer[dst], &bfr[items_added], n*sizeof(T));
//     items_added += n;
//     _size += n;
//   }
// }

// // Returns min(size, len) items in bfr.
// template<typename T>
// uint16_t CircularQueue<T>::dequeue(T* bfr, uint16_t len) {
//   const uint16_t items_to_transfer = std::min(len, _size);
//   uint16_t items_transfered = 0;
//   // Should iterate twice at most.
//   while (items_transfered < items_to_transfer) {
//     const uint16_t limit1 = items_to_transfer - items_transfered;
//     const uint16_t limit2 = _capacity - _start;
//     const uint16_t n = std::min(limit1, limit2);
//     memcpy(&bfr[items_transfered], &_buffer[_start], n*sizeof(T));
//     items_transfered += n;
//     _size -= n;
//     _start += n;
//     normalize_index(_start);
//   }
//   return items_to_transfer;
// }

